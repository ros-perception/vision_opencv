Index: include/opencv/cxflann.h
===================================================================
--- include/opencv/cxflann.h	(revision 3028)
+++ include/opencv/cxflann.h	(working copy)
@@ -45,14 +45,14 @@
 
 #ifdef __cplusplus
 
-namespace flann
+namespace cvflann
 {
 	class Index;
 }
 
 namespace cv {
 
-namespace flann {
+namespace cvflann {
 
 /* Nearest neighbor index algorithms */
 enum flann_algorithm_t {
@@ -89,7 +89,7 @@
 {
 public:
     virtual ~IndexFactory() {}
-	virtual ::flann::Index* createIndex(const Mat& dataset) const = 0;
+	virtual ::cvflann::Index* createIndex(const Mat& dataset) const = 0;
 };
 
 struct CV_EXPORTS IndexParams : public IndexFactory {
@@ -101,7 +101,7 @@
 struct CV_EXPORTS LinearIndexParams : public IndexParams {
 	LinearIndexParams() {};
 
-	::flann::Index* createIndex(const Mat& dataset) const;
+	::cvflann::Index* createIndex(const Mat& dataset) const;
 };
 
 
@@ -111,7 +111,7 @@
 
 	int trees;                 // number of randomized trees to use (for kdtree)
 
-	::flann::Index* createIndex(const Mat& dataset) const;
+	::cvflann::Index* createIndex(const Mat& dataset) const;
 };
 
 struct CV_EXPORTS KMeansIndexParams : public IndexParams {
@@ -127,7 +127,7 @@
 	flann_centers_init_t centers_init;          // algorithm used for picking the initial cluster centers for kmeans tree
     float cb_index;            // cluster boundary index. Used when searching the kmeans tree
 
-    ::flann::Index* createIndex(const Mat& dataset) const;
+    ::cvflann::Index* createIndex(const Mat& dataset) const;
 };
 
 
@@ -146,7 +146,7 @@
 	flann_centers_init_t centers_init;          // algorithm used for picking the initial cluster centers for kmeans tree
     float cb_index;            // cluster boundary index. Used when searching the kmeans tree
 
-    ::flann::Index* createIndex(const Mat& dataset) const;
+    ::cvflann::Index* createIndex(const Mat& dataset) const;
 };
 
 
@@ -163,7 +163,7 @@
 	float memory_weight;       // index memory weighting factor
     float sample_fraction;     // what fraction of the dataset to use for autotuning
 
-    ::flann::Index* createIndex(const Mat& dataset) const;
+    ::cvflann::Index* createIndex(const Mat& dataset) const;
 };
 
 
@@ -173,7 +173,7 @@
 
 	std::string filename;		// filename of the stored index
 
-	::flann::Index* createIndex(const Mat& dataset) const;
+	::cvflann::Index* createIndex(const Mat& dataset) const;
 };
 
 
@@ -187,7 +187,7 @@
 
 
 class CV_EXPORTS Index {
-	::flann::Index* nnIndex;
+	::cvflann::Index* nnIndex;
 
 public:
 	Index(const Mat& features, const IndexParams& params);
Index: include/opencv/cvaux.hpp
===================================================================
--- include/opencv/cvaux.hpp	(revision 3028)
+++ include/opencv/cvaux.hpp	(working copy)
@@ -1802,7 +1802,7 @@
     CvMat* m_pca_hr_eigenvectors; // PCA eigenvectors for large patches
     OneWayDescriptor* m_pca_descriptors; // an array of PCA descriptors
 
-    cv::flann::Index* m_pca_descriptors_tree;
+    cv::cvflann::Index* m_pca_descriptors_tree;
     CvMat* m_pca_descriptors_matrix;
 
     CvAffinePose* m_poses; // array of poses
Index: src/cxcore/cxflann.cpp
===================================================================
--- src/cxcore/cxflann.cpp	(revision 3028)
+++ src/cxcore/cxflann.cpp	(working copy)
@@ -38,72 +38,72 @@
 namespace cv
 {
 
-namespace flann {
+namespace cvflann {
 
-::flann::Index* LinearIndexParams::createIndex(const Mat& dataset) const
+::cvflann::Index* LinearIndexParams::createIndex(const Mat& dataset) const
 {
 	CV_Assert(dataset.type() == CV_32F);
 	CV_Assert(dataset.isContinuous());
 
-	// TODO: fix ::flann::Matrix class so it can be constructed with a const float*
-	::flann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
+	// TODO: fix ::cvflann::Matrix class so it can be constructed with a const float*
+	::cvflann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
 
-	return new ::flann::Index(mat, ::flann::LinearIndexParams());
+	return new ::cvflann::Index(mat, ::cvflann::LinearIndexParams());
 }
 
-::flann::Index* KDTreeIndexParams::createIndex(const Mat& dataset) const
+::cvflann::Index* KDTreeIndexParams::createIndex(const Mat& dataset) const
 {
 	CV_Assert(dataset.type() == CV_32F);
 	CV_Assert(dataset.isContinuous());
 
-	// TODO: fix ::flann::Matrix class so it can be constructed with a const float*
-	::flann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
+	// TODO: fix ::cvflann::Matrix class so it can be constructed with a const float*
+	::cvflann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
 
-	return new ::flann::Index(mat, ::flann::KDTreeIndexParams(trees));
+	return new ::cvflann::Index(mat, ::cvflann::KDTreeIndexParams(trees));
 }
 
-::flann::Index* KMeansIndexParams::createIndex(const Mat& dataset) const
+::cvflann::Index* KMeansIndexParams::createIndex(const Mat& dataset) const
 {
 	CV_Assert(dataset.type() == CV_32F);
 	CV_Assert(dataset.isContinuous());
 
-	// TODO: fix ::flann::Matrix class so it can be constructed with a const float*
-	::flann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
+	// TODO: fix ::cvflann::Matrix class so it can be constructed with a const float*
+	::cvflann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
 
-	return new ::flann::Index(mat, ::flann::KMeansIndexParams(branching,iterations, (::flann_centers_init_t)centers_init, cb_index));
+	return new ::cvflann::Index(mat, ::cvflann::KMeansIndexParams(branching,iterations, (::flann_centers_init_t)centers_init, cb_index));
 }
 
-::flann::Index* CompositeIndexParams::createIndex(const Mat& dataset) const
+::cvflann::Index* CompositeIndexParams::createIndex(const Mat& dataset) const
 {
 	CV_Assert(dataset.type() == CV_32F);
 	CV_Assert(dataset.isContinuous());
 
-	// TODO: fix ::flann::Matrix class so it can be constructed with a const float*
-	::flann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
+	// TODO: fix ::cvflann::Matrix class so it can be constructed with a const float*
+	::cvflann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
 
-	return new ::flann::Index(mat, ::flann::CompositeIndexParams(trees, branching, iterations, (::flann_centers_init_t)centers_init, cb_index));
+	return new ::cvflann::Index(mat, ::cvflann::CompositeIndexParams(trees, branching, iterations, (::flann_centers_init_t)centers_init, cb_index));
 }
 
-::flann::Index* AutotunedIndexParams::createIndex(const Mat& dataset) const
+::cvflann::Index* AutotunedIndexParams::createIndex(const Mat& dataset) const
 {
 	CV_Assert(dataset.type() == CV_32F);
 	CV_Assert(dataset.isContinuous());
 
-	// TODO: fix ::flann::Matrix class so it can be constructed with a const float*
-	::flann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
+	// TODO: fix ::cvflann::Matrix class so it can be constructed with a const float*
+	::cvflann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
 
-	return new ::flann::Index(mat, ::flann::AutotunedIndexParams(target_precision, build_weight, memory_weight, sample_fraction));
+	return new ::cvflann::Index(mat, ::cvflann::AutotunedIndexParams(target_precision, build_weight, memory_weight, sample_fraction));
 }
 
-::flann::Index* SavedIndexParams::createIndex(const Mat& dataset) const
+::cvflann::Index* SavedIndexParams::createIndex(const Mat& dataset) const
 {
 	CV_Assert(dataset.type() == CV_32F);
 	CV_Assert(dataset.isContinuous());
 
-	// TODO: fix ::flann::Matrix class so it can be constructed with a const float*
-	::flann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
+	// TODO: fix ::cvflann::Matrix class so it can be constructed with a const float*
+	::cvflann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
 
-	return new ::flann::Index(mat, ::flann::SavedIndexParams(filename));
+	return new ::cvflann::Index(mat, ::cvflann::SavedIndexParams(filename));
 }
 
 
@@ -121,11 +121,11 @@
 void Index::knnSearch(const vector<float>& query, vector<int>& indices, vector<float>& dists, int knn, const SearchParams& searchParams)
 {
 
-	::flann::Matrix<float> m_query(1, query.size(), (float*)&query[0]);
-	::flann::Matrix<int> m_indices(1, indices.size(), &indices[0]);
-	::flann::Matrix<float> m_dists(1, dists.size(), &dists[0]);
+	::cvflann::Matrix<float> m_query(1, query.size(), (float*)&query[0]);
+	::cvflann::Matrix<int> m_indices(1, indices.size(), &indices[0]);
+	::cvflann::Matrix<float> m_dists(1, dists.size(), &dists[0]);
 
-	nnIndex->knnSearch(m_query,m_indices,m_dists,knn,::flann::SearchParams(searchParams.checks));
+	nnIndex->knnSearch(m_query,m_indices,m_dists,knn,::cvflann::SearchParams(searchParams.checks));
 }
 
 
@@ -134,26 +134,26 @@
 
 	CV_Assert(queries.type() == CV_32F);
 	CV_Assert(queries.isContinuous());
-	::flann::Matrix<float> m_queries(queries.rows, queries.cols, (float*)queries.ptr<float>(0));
+	::cvflann::Matrix<float> m_queries(queries.rows, queries.cols, (float*)queries.ptr<float>(0));
 
 	CV_Assert(indices.type() == CV_32S);
 	CV_Assert(indices.isContinuous());
-	::flann::Matrix<int> m_indices(indices.rows, indices.cols, (int*)indices.ptr<int>(0));
+	::cvflann::Matrix<int> m_indices(indices.rows, indices.cols, (int*)indices.ptr<int>(0));
 
 	CV_Assert(dists.type() == CV_32F);
 	CV_Assert(dists.isContinuous());
-	::flann::Matrix<float> m_dists(dists.rows, dists.cols, (float*)dists.ptr<float>(0));
+	::cvflann::Matrix<float> m_dists(dists.rows, dists.cols, (float*)dists.ptr<float>(0));
 
-	nnIndex->knnSearch(m_queries,m_indices,m_dists,knn,::flann::SearchParams(searchParams.checks));
+	nnIndex->knnSearch(m_queries,m_indices,m_dists,knn,::cvflann::SearchParams(searchParams.checks));
 }
 
 int Index::radiusSearch(const vector<float>& query, vector<int>& indices, vector<float>& dists, float radius, const SearchParams& searchParams)
 {
-	::flann::Matrix<float> m_query(1, query.size(), (float*)&query[0]);
-	::flann::Matrix<int> m_indices(1, indices.size(), &indices[0]);
-	::flann::Matrix<float> m_dists(1, dists.size(), &dists[0]);
+	::cvflann::Matrix<float> m_query(1, query.size(), (float*)&query[0]);
+	::cvflann::Matrix<int> m_indices(1, indices.size(), &indices[0]);
+	::cvflann::Matrix<float> m_dists(1, dists.size(), &dists[0]);
 
-	return nnIndex->radiusSearch(m_query,m_indices,m_dists,radius,::flann::SearchParams(searchParams.checks));
+	return nnIndex->radiusSearch(m_query,m_indices,m_dists,radius,::cvflann::SearchParams(searchParams.checks));
 }
 
 
@@ -161,17 +161,17 @@
 {
 	CV_Assert(query.type() == CV_32F);
 	CV_Assert(query.isContinuous());
-	::flann::Matrix<float> m_query(query.rows, query.cols, (float*)query.ptr<float>(0));
+	::cvflann::Matrix<float> m_query(query.rows, query.cols, (float*)query.ptr<float>(0));
 
 	CV_Assert(indices.type() == CV_32S);
 	CV_Assert(indices.isContinuous());
-	::flann::Matrix<int> m_indices(indices.rows, indices.cols, (int*)indices.ptr<int>(0));
+	::cvflann::Matrix<int> m_indices(indices.rows, indices.cols, (int*)indices.ptr<int>(0));
 
 	CV_Assert(dists.type() == CV_32F);
 	CV_Assert(dists.isContinuous());
-	::flann::Matrix<float> m_dists(dists.rows, dists.cols, (float*)dists.ptr<float>(0));
+	::cvflann::Matrix<float> m_dists(dists.rows, dists.cols, (float*)dists.ptr<float>(0));
 
-	return nnIndex->radiusSearch(m_query,m_indices,m_dists,radius,::flann::SearchParams(searchParams.checks));
+	return nnIndex->radiusSearch(m_query,m_indices,m_dists,radius,::cvflann::SearchParams(searchParams.checks));
 }
 
 
@@ -195,13 +195,13 @@
 {
 	CV_Assert(features.type() == CV_32F);
 	CV_Assert(features.isContinuous());
-	::flann::Matrix<float> m_features(features.rows, features.cols, (float*)features.ptr<float>(0));
+	::cvflann::Matrix<float> m_features(features.rows, features.cols, (float*)features.ptr<float>(0));
 
 	CV_Assert(features.type() == CV_32F);
 	CV_Assert(features.isContinuous());
-	::flann::Matrix<float> m_centers(centers.rows, centers.cols, (float*)centers.ptr<float>(0));
+	::cvflann::Matrix<float> m_centers(centers.rows, centers.cols, (float*)centers.ptr<float>(0));
 
-	return ::flann::hierarchicalClustering(m_features, m_centers, ::flann::KMeansIndexParams(params.branching, params.iterations,
+	return ::cvflann::hierarchicalClustering(m_features, m_centers, ::cvflann::KMeansIndexParams(params.branching, params.iterations,
 			(::flann_centers_init_t)params.centers_init, params.cb_index));
 }
 
Index: src/cvaux/cvoneway.cpp
===================================================================
--- src/cvaux/cvoneway.cpp	(revision 3028)
+++ src/cvaux/cvoneway.cpp	(working copy)
@@ -150,7 +150,7 @@
                               std::vector<int>& desc_idxs, std::vector<int>&  pose_idxs, std::vector<float>& distances,
                               CvMat* avg = 0, CvMat* eigenvalues = 0);
     
-    void FindOneWayDescriptor(cv::flann::Index* m_pca_descriptors_tree, CvSize patch_size, int m_pca_dim_low, int m_pose_count, IplImage* patch, int& desc_idx, int& pose_idx, float& distance,
+    void FindOneWayDescriptor(cv::cvflann::Index* m_pca_descriptors_tree, CvSize patch_size, int m_pca_dim_low, int m_pose_count, IplImage* patch, int& desc_idx, int& pose_idx, float& distance,
                               CvMat* avg = 0, CvMat* eigenvalues = 0);
     
     void FindOneWayDescriptorEx(int desc_count, const OneWayDescriptor* descriptors, IplImage* patch,
@@ -164,7 +164,7 @@
                                 std::vector<float>& distances, std::vector<float>& scales,
                                 CvMat* avg, CvMat* eigenvectors);
     
-    void FindOneWayDescriptorEx(cv::flann::Index* m_pca_descriptors_tree, CvSize patch_size, int m_pca_dim_low, int m_pose_count, IplImage* patch,
+    void FindOneWayDescriptorEx(cv::cvflann::Index* m_pca_descriptors_tree, CvSize patch_size, int m_pca_dim_low, int m_pose_count, IplImage* patch,
                                 float scale_min, float scale_max, float scale_step,
                                 int& desc_idx, int& pose_idx, float& distance, float& scale,
                                 CvMat* avg, CvMat* eigenvectors);
@@ -801,7 +801,7 @@
     
 #if defined(_KDTREE)
     
-    void FindOneWayDescriptor(cv::flann::Index* m_pca_descriptors_tree, CvSize patch_size, int m_pca_dim_low, int m_pose_count, IplImage* patch, int& desc_idx, int& pose_idx, float& distance,
+    void FindOneWayDescriptor(cv::cvflann::Index* m_pca_descriptors_tree, CvSize patch_size, int m_pca_dim_low, int m_pose_count, IplImage* patch, int& desc_idx, int& pose_idx, float& distance,
                               CvMat* avg, CvMat* eigenvectors)
     {
         desc_idx = -1;
@@ -849,8 +849,8 @@
         //--------
         
 		//float* target = new float[m_pca_dim_low];
-		//::flann::KNNResultSet res(1,pca_coeffs->data.fl,m_pca_dim_low);
-		//::flann::SearchParams params;
+		//::cvflann::KNNResultSet res(1,pca_coeffs->data.fl,m_pca_dim_low);
+		//::cvflann::SearchParams params;
 		//params.checks = -1;
         
 		//int maxDepth = 1000000;
@@ -876,7 +876,7 @@
 			object_ptr[i] = pca_coeffs->data.fl[i];
 		}
         
-		m_pca_descriptors_tree->knnSearch(m_object, m_indices, m_dists, 1, cv::flann::SearchParams(-1) );
+		m_pca_descriptors_tree->knnSearch(m_object, m_indices, m_dists, 1, cv::cvflann::SearchParams(-1) );
         
 		desc_idx = ((int*)(m_indices.ptr<int>(0)))[0] / m_pose_count;
 		pose_idx = ((int*)(m_indices.ptr<int>(0)))[0] % m_pose_count;
@@ -1110,7 +1110,7 @@
     }
     
 #if defined(_KDTREE)
-    void FindOneWayDescriptorEx(cv::flann::Index* m_pca_descriptors_tree, CvSize patch_size, int m_pca_dim_low,
+    void FindOneWayDescriptorEx(cv::cvflann::Index* m_pca_descriptors_tree, CvSize patch_size, int m_pca_dim_low,
                                 int m_pose_count, IplImage* patch,
                                 float scale_min, float scale_max, float scale_step,
                                 int& desc_idx, int& pose_idx, float& distance, float& scale,
@@ -1634,13 +1634,13 @@
         int pca_dim_low = this->GetDescriptor(0)->GetPCADimLow();
         
         //if (!m_pca_descriptors_matrix)
-        //	m_pca_descriptors_matrix = new ::flann::Matrix<float>(n*m_pose_count,pca_dim_low);
+        //	m_pca_descriptors_matrix = new ::cvflann::Matrix<float>(n*m_pose_count,pca_dim_low);
         //else
         //{
         //	if ((m_pca_descriptors_matrix->cols != pca_dim_low)&&(m_pca_descriptors_matrix->rows != n*m_pose_count))
         //	{
         //		delete m_pca_descriptors_matrix;
-        //		m_pca_descriptors_matrix = new ::flann::Matrix<float>(n*m_pose_count,pca_dim_low);
+        //		m_pca_descriptors_matrix = new ::cvflann::Matrix<float>(n*m_pose_count,pca_dim_low);
         //	}
         //}
         
@@ -1658,10 +1658,10 @@
         }
         cv::Mat pca_descriptors_mat(m_pca_descriptors_matrix,false);
         
-        //::flann::KDTreeIndexParams params;
+        //::cvflann::KDTreeIndexParams params;
         //params.trees = 1;
         //m_pca_descriptors_tree = new KDTree(pca_descriptors_mat);
-        m_pca_descriptors_tree = new cv::flann::Index(pca_descriptors_mat,cv::flann::KDTreeIndexParams(1));
+        m_pca_descriptors_tree = new cv::cvflann::Index(pca_descriptors_mat,cv::cvflann::KDTreeIndexParams(1));
         //cvReleaseMat(&m_pca_descriptors_matrix);
         //m_pca_descriptors_tree->buildIndex();
     }
Index: tests/cv/src/anearestneighbors.cpp
===================================================================
--- tests/cv/src/anearestneighbors.cpp	(revision 3028)
+++ tests/cv/src/anearestneighbors.cpp	(working copy)
@@ -47,7 +47,7 @@
 #include <iostream>
 
 using namespace cv;
-using namespace cv::flann;
+using namespace cv::cvflann;
 
 //--------------------------------------------------------------------------------
 class NearestNeighborTest : public CvTest
Index: samples/c/find_obj.cpp
===================================================================
--- samples/c/find_obj.cpp	(revision 3028)
+++ samples/c/find_obj.cpp	(working copy)
@@ -138,8 +138,8 @@
     // find nearest neighbors using FLANN
     cv::Mat m_indices(objectDescriptors->total, 2, CV_32S);
     cv::Mat m_dists(objectDescriptors->total, 2, CV_32F);
-    cv::flann::Index flann_index(m_image, cv::flann::KDTreeIndexParams(4));  // using 4 randomized kdtrees
-    flann_index.knnSearch(m_object, m_indices, m_dists, 2, cv::flann::SearchParams(64) ); // maximum number of leafs checked
+    cv::cvflann::Index flann_index(m_image, cv::cvflann::KDTreeIndexParams(4));  // using 4 randomized kdtrees
+    flann_index.knnSearch(m_object, m_indices, m_dists, 2, cv::cvflann::SearchParams(64) ); // maximum number of leafs checked
 
     int* indices_ptr = m_indices.ptr<int>(0);
     float* dists_ptr = m_dists.ptr<float>(0);
Index: 3rdparty/include/flann/flann.hpp
===================================================================
--- 3rdparty/include/flann/flann.hpp	(revision 3028)
+++ 3rdparty/include/flann/flann.hpp	(working copy)
@@ -40,7 +40,7 @@
 
 #include "flann.h"
 
-namespace flann
+namespace cvflann
 {
 
 class NNIndex;
Index: 3rdparty/include/flann/random.h
===================================================================
--- 3rdparty/include/flann/random.h	(revision 3028)
+++ 3rdparty/include/flann/random.h	(working copy)
@@ -37,7 +37,7 @@
 
 using namespace std;
 
-namespace flann
+namespace cvflann
 {
 
 /**
Index: 3rdparty/include/flann/matrix.h
===================================================================
--- 3rdparty/include/flann/matrix.h	(revision 3028)
+++ 3rdparty/include/flann/matrix.h	(working copy)
@@ -35,7 +35,7 @@
 #include "random.h"
 
 
-namespace flann
+namespace cvflann
 {
 /**
 * Class implementing a generic rectangular dataset.
Index: 3rdparty/include/flann/common.h
===================================================================
--- 3rdparty/include/flann/common.h	(revision 3028)
+++ 3rdparty/include/flann/common.h	(working copy)
@@ -36,7 +36,7 @@
 
 #include <stdexcept>
 
-namespace flann
+namespace cvflann
 {
 class FLANNException : public std::runtime_error {
  public:
Index: 3rdparty/flann/flann.cpp
===================================================================
--- 3rdparty/flann/flann.cpp	(revision 3028)
+++ 3rdparty/flann/flann.cpp	(working copy)
@@ -58,7 +58,7 @@
 #endif
 
 
-namespace flann
+namespace cvflann
 {
 
 typedef ObjectFactory<IndexParams, flann_algorithm_t> ParamsFactory;
@@ -224,7 +224,7 @@
 
 
 
-using namespace flann;
+using namespace cvflann;
 
 typedef NNIndex* NNIndexPtr;
 typedef Matrix<float>* MatrixPtr;
Index: 3rdparty/flann/flann.hpp
===================================================================
--- 3rdparty/flann/flann.hpp	(revision 3028)
+++ 3rdparty/flann/flann.hpp	(working copy)
@@ -40,7 +40,7 @@
 
 #include "flann.h"
 
-namespace flann
+namespace cvflann
 {
 
 class NNIndex;
Index: 3rdparty/flann/algorithms/composite_index.h
===================================================================
--- 3rdparty/flann/algorithms/composite_index.h	(revision 3028)
+++ 3rdparty/flann/algorithms/composite_index.h	(working copy)
@@ -34,7 +34,7 @@
 #include "constants.h"
 #include "nn_index.h"
 
-namespace flann
+namespace cvflann
 {
 
 class CompositeIndex : public NNIndex
Index: 3rdparty/flann/algorithms/dist.cpp
===================================================================
--- 3rdparty/flann/algorithms/dist.cpp	(revision 3028)
+++ 3rdparty/flann/algorithms/dist.cpp	(working copy)
@@ -30,7 +30,7 @@
 
 #include "dist.h"
 
-namespace flann
+namespace cvflann
 {
 
 /** Global variable indicating the distance metric
Index: 3rdparty/flann/algorithms/autotuned_index.h
===================================================================
--- 3rdparty/flann/algorithms/autotuned_index.h	(revision 3028)
+++ 3rdparty/flann/algorithms/autotuned_index.h	(working copy)
@@ -36,7 +36,7 @@
 #include "ground_truth.h"
 #include "index_testing.h"
 
-namespace flann
+namespace cvflann
 {
 
 class AutotunedIndex : public NNIndex
Index: 3rdparty/flann/algorithms/linear_index.h
===================================================================
--- 3rdparty/flann/algorithms/linear_index.h	(revision 3028)
+++ 3rdparty/flann/algorithms/linear_index.h	(working copy)
@@ -34,7 +34,7 @@
 #include "constants.h"
 #include "nn_index.h"
 
-namespace flann
+namespace cvflann
 {
 
 class LinearIndex : public NNIndex {
Index: 3rdparty/flann/algorithms/nn_index.h
===================================================================
--- 3rdparty/flann/algorithms/nn_index.h	(revision 3028)
+++ 3rdparty/flann/algorithms/nn_index.h	(working copy)
@@ -41,7 +41,7 @@
 
 using namespace std;
 
-namespace flann
+namespace cvflann
 {
 
 class ResultSet;
Index: 3rdparty/flann/algorithms/dist.h
===================================================================
--- 3rdparty/flann/algorithms/dist.h	(revision 3028)
+++ 3rdparty/flann/algorithms/dist.h	(working copy)
@@ -36,7 +36,7 @@
 
 #include "constants.h"
 
-namespace flann
+namespace cvflann
 {
 
 /**
Index: 3rdparty/flann/algorithms/kdtree_index.h
===================================================================
--- 3rdparty/flann/algorithms/kdtree_index.h	(revision 3028)
+++ 3rdparty/flann/algorithms/kdtree_index.h	(working copy)
@@ -48,7 +48,7 @@
 using namespace std;
 
 
-namespace flann
+namespace cvflann
 {
 
 
Index: 3rdparty/flann/algorithms/kmeans_index.h
===================================================================
--- 3rdparty/flann/algorithms/kmeans_index.h	(revision 3028)
+++ 3rdparty/flann/algorithms/kmeans_index.h	(working copy)
@@ -50,7 +50,7 @@
 using namespace std;
 
 
-namespace flann
+namespace cvflann
 {
 
 /**
Index: 3rdparty/flann/nn/index_testing.cpp
===================================================================
--- 3rdparty/flann/nn/index_testing.cpp	(revision 3028)
+++ 3rdparty/flann/nn/index_testing.cpp	(working copy)
@@ -40,7 +40,7 @@
 #include <string.h>
 #include <stdlib.h>
 
-namespace flann
+namespace cvflann
 {
 
 const float SEARCH_EPS = 0.001f;
Index: 3rdparty/flann/nn/simplex_downhill.h
===================================================================
--- 3rdparty/flann/nn/simplex_downhill.h	(revision 3028)
+++ 3rdparty/flann/nn/simplex_downhill.h	(working copy)
@@ -31,7 +31,7 @@
 #ifndef SIMPLEX_DOWNHILL_H
 #define SIMPLEX_DOWNHILL_H
 
-namespace flann
+namespace cvflann
 {
 
 /**
Index: 3rdparty/flann/nn/ground_truth.h
===================================================================
--- 3rdparty/flann/nn/ground_truth.h	(revision 3028)
+++ 3rdparty/flann/nn/ground_truth.h	(working copy)
@@ -34,7 +34,7 @@
 #include "matrix.h"
 #include "dist.h"
 
-namespace flann
+namespace cvflann
 {
 
 template <typename T>
Index: 3rdparty/flann/nn/index_testing.h
===================================================================
--- 3rdparty/flann/nn/index_testing.h	(revision 3028)
+++ 3rdparty/flann/nn/index_testing.h	(working copy)
@@ -38,7 +38,7 @@
 
 using namespace std;
 
-namespace flann
+namespace cvflann
 {
 
 void search_for_neighbors(NNIndex& index, const Matrix<float>& testset, Matrix<int>& result, Matrix<float>& dists, const SearchParams &searchParams, int skip = 0);
Index: 3rdparty/flann/util/result_set.h
===================================================================
--- 3rdparty/flann/util/result_set.h	(revision 3028)
+++ 3rdparty/flann/util/result_set.h	(working copy)
@@ -40,7 +40,7 @@
 using namespace std;
 
 
-namespace flann
+namespace cvflann
 {
 
 /* This record represents a branch point when finding neighbors in
Index: 3rdparty/flann/util/logger.cpp
===================================================================
--- 3rdparty/flann/util/logger.cpp	(revision 3028)
+++ 3rdparty/flann/util/logger.cpp	(working copy)
@@ -36,7 +36,7 @@
 
 using namespace std;
 
-namespace flann
+namespace cvflann
 {
 
 Logger logger;
Index: 3rdparty/flann/util/random.cpp
===================================================================
--- 3rdparty/flann/util/random.cpp	(revision 3028)
+++ 3rdparty/flann/util/random.cpp	(working copy)
@@ -31,7 +31,7 @@
 #include "random.h"
 
 
-namespace flann
+namespace cvflann
 {
 
 void seed_random(unsigned int seed)
Index: 3rdparty/flann/util/heap.h
===================================================================
--- 3rdparty/flann/util/heap.h	(revision 3028)
+++ 3rdparty/flann/util/heap.h	(working copy)
@@ -35,7 +35,7 @@
 #include <algorithm>
 using namespace std;
 
-namespace flann
+namespace cvflann
 {
 
 /**
Index: 3rdparty/flann/util/object_factory.h
===================================================================
--- 3rdparty/flann/util/object_factory.h	(revision 3028)
+++ 3rdparty/flann/util/object_factory.h	(working copy)
@@ -33,7 +33,7 @@
 
 #include <map>
 
-namespace flann
+namespace cvflann
 {
 
 template<typename BaseClass, typename DerivedClass>
Index: 3rdparty/flann/util/logger.h
===================================================================
--- 3rdparty/flann/util/logger.h	(revision 3028)
+++ 3rdparty/flann/util/logger.h	(working copy)
@@ -39,7 +39,7 @@
 
 using namespace std;
 
-namespace flann
+namespace cvflann
 {
 
 class Logger
Index: 3rdparty/flann/util/allocator.h
===================================================================
--- 3rdparty/flann/util/allocator.h	(revision 3028)
+++ 3rdparty/flann/util/allocator.h	(working copy)
@@ -35,7 +35,7 @@
 #include <stdio.h>
 
 
-namespace flann
+namespace cvflann
 {
 
 /**
Index: 3rdparty/flann/util/random.h
===================================================================
--- 3rdparty/flann/util/random.h	(revision 3028)
+++ 3rdparty/flann/util/random.h	(working copy)
@@ -37,7 +37,7 @@
 
 using namespace std;
 
-namespace flann
+namespace cvflann
 {
 
 /**
Index: 3rdparty/flann/util/timer.h
===================================================================
--- 3rdparty/flann/util/timer.h	(revision 3028)
+++ 3rdparty/flann/util/timer.h	(working copy)
@@ -34,7 +34,7 @@
 #include <time.h>
 
 
-namespace flann
+namespace cvflann
 {
 
 /**
Index: 3rdparty/flann/util/saving.cpp
===================================================================
--- 3rdparty/flann/util/saving.cpp	(revision 3028)
+++ 3rdparty/flann/util/saving.cpp	(working copy)
@@ -33,7 +33,7 @@
 #include "nn_index.h"
 #include <cstdio>
 
-namespace flann
+namespace cvflann
 {
 
 const char FLANN_SIGNATURE[] = "FLANN_INDEX";
Index: 3rdparty/flann/util/matrix.h
===================================================================
--- 3rdparty/flann/util/matrix.h	(revision 3028)
+++ 3rdparty/flann/util/matrix.h	(working copy)
@@ -35,7 +35,7 @@
 #include <random.h>
 
 
-namespace flann
+namespace cvflann
 {
 /**
 * Class implementing a generic rectangular dataset.
Index: 3rdparty/flann/util/saving.h
===================================================================
--- 3rdparty/flann/util/saving.h	(revision 3028)
+++ 3rdparty/flann/util/saving.h	(working copy)
@@ -35,7 +35,7 @@
 #include "nn_index.h"
 
 
-namespace flann
+namespace cvflann
 {
 
 /**
Index: 3rdparty/flann/util/common.h
===================================================================
--- 3rdparty/flann/util/common.h	(revision 3028)
+++ 3rdparty/flann/util/common.h	(working copy)
@@ -36,7 +36,7 @@
 
 #include <stdexcept>
 
-namespace flann
+namespace cvflann
 {
 class FLANNException : public std::runtime_error {
  public:
