Index: modules/core/include/opencv2/core/flann.hpp
===================================================================
--- modules/core/include/opencv2/core/flann.hpp	(revision 3093)
+++ modules/core/include/opencv2/core/flann.hpp	(working copy)
@@ -45,7 +45,7 @@
 
 #ifdef __cplusplus
 
-namespace flann
+namespace cvflann
 {
 	class Index;
 }
@@ -89,7 +89,7 @@
 {
 public:
     virtual ~IndexFactory() {}
-	virtual ::flann::Index* createIndex(const Mat& dataset) const = 0;
+	virtual ::cvflann::Index* createIndex(const Mat& dataset) const = 0;
 };
 
 struct CV_EXPORTS IndexParams : public IndexFactory {
@@ -101,7 +101,7 @@
 struct CV_EXPORTS LinearIndexParams : public IndexParams {
 	LinearIndexParams() {};
 
-	::flann::Index* createIndex(const Mat& dataset) const;
+	::cvflann::Index* createIndex(const Mat& dataset) const;
 };
 
 
@@ -111,7 +111,7 @@
 
 	int trees;                 // number of randomized trees to use (for kdtree)
 
-	::flann::Index* createIndex(const Mat& dataset) const;
+	::cvflann::Index* createIndex(const Mat& dataset) const;
 };
 
 struct CV_EXPORTS KMeansIndexParams : public IndexParams {
@@ -127,7 +127,7 @@
 	flann_centers_init_t centers_init;          // algorithm used for picking the initial cluster centers for kmeans tree
     float cb_index;            // cluster boundary index. Used when searching the kmeans tree
 
-    ::flann::Index* createIndex(const Mat& dataset) const;
+    ::cvflann::Index* createIndex(const Mat& dataset) const;
 };
 
 
@@ -146,7 +146,7 @@
 	flann_centers_init_t centers_init;          // algorithm used for picking the initial cluster centers for kmeans tree
     float cb_index;            // cluster boundary index. Used when searching the kmeans tree
 
-    ::flann::Index* createIndex(const Mat& dataset) const;
+    ::cvflann::Index* createIndex(const Mat& dataset) const;
 };
 
 
@@ -163,7 +163,7 @@
 	float memory_weight;       // index memory weighting factor
     float sample_fraction;     // what fraction of the dataset to use for autotuning
 
-    ::flann::Index* createIndex(const Mat& dataset) const;
+    ::cvflann::Index* createIndex(const Mat& dataset) const;
 };
 
 
@@ -173,7 +173,7 @@
 
 	std::string filename;		// filename of the stored index
 
-	::flann::Index* createIndex(const Mat& dataset) const;
+	::cvflann::Index* createIndex(const Mat& dataset) const;
 };
 
 
@@ -187,7 +187,7 @@
 
 
 class CV_EXPORTS Index {
-	::flann::Index* nnIndex;
+	::cvflann::Index* nnIndex;
 
 public:
 	Index(const Mat& features, const IndexParams& params);
Index: modules/core/src/flann.cpp
===================================================================
--- modules/core/src/flann.cpp	(revision 3093)
+++ modules/core/src/flann.cpp	(working copy)
@@ -40,70 +40,70 @@
 
 namespace flann {
 
-::flann::Index* LinearIndexParams::createIndex(const Mat& dataset) const
+::cvflann::Index* LinearIndexParams::createIndex(const Mat& dataset) const
 {
 	CV_Assert(dataset.type() == CV_32F);
 	CV_Assert(dataset.isContinuous());
 
-	// TODO: fix ::flann::Matrix class so it can be constructed with a const float*
-	::flann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
+	// TODO: fix ::cvflann::Matrix class so it can be constructed with a const float*
+	::cvflann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
 
-	return new ::flann::Index(mat, ::flann::LinearIndexParams());
+	return new ::cvflann::Index(mat, ::cvflann::LinearIndexParams());
 }
 
-::flann::Index* KDTreeIndexParams::createIndex(const Mat& dataset) const
+::cvflann::Index* KDTreeIndexParams::createIndex(const Mat& dataset) const
 {
 	CV_Assert(dataset.type() == CV_32F);
 	CV_Assert(dataset.isContinuous());
 
-	// TODO: fix ::flann::Matrix class so it can be constructed with a const float*
-	::flann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
+	// TODO: fix ::cvflann::Matrix class so it can be constructed with a const float*
+	::cvflann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
 
-	return new ::flann::Index(mat, ::flann::KDTreeIndexParams(trees));
+	return new ::cvflann::Index(mat, ::cvflann::KDTreeIndexParams(trees));
 }
 
-::flann::Index* KMeansIndexParams::createIndex(const Mat& dataset) const
+::cvflann::Index* KMeansIndexParams::createIndex(const Mat& dataset) const
 {
 	CV_Assert(dataset.type() == CV_32F);
 	CV_Assert(dataset.isContinuous());
 
-	// TODO: fix ::flann::Matrix class so it can be constructed with a const float*
-	::flann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
+	// TODO: fix ::cvflann::Matrix class so it can be constructed with a const float*
+	::cvflann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
 
-	return new ::flann::Index(mat, ::flann::KMeansIndexParams(branching,iterations, (::flann_centers_init_t)centers_init, cb_index));
+	return new ::cvflann::Index(mat, ::cvflann::KMeansIndexParams(branching,iterations, (::flann_centers_init_t)centers_init, cb_index));
 }
 
-::flann::Index* CompositeIndexParams::createIndex(const Mat& dataset) const
+::cvflann::Index* CompositeIndexParams::createIndex(const Mat& dataset) const
 {
 	CV_Assert(dataset.type() == CV_32F);
 	CV_Assert(dataset.isContinuous());
 
-	// TODO: fix ::flann::Matrix class so it can be constructed with a const float*
-	::flann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
+	// TODO: fix ::cvflann::Matrix class so it can be constructed with a const float*
+	::cvflann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
 
-	return new ::flann::Index(mat, ::flann::CompositeIndexParams(trees, branching, iterations, (::flann_centers_init_t)centers_init, cb_index));
+	return new ::cvflann::Index(mat, ::cvflann::CompositeIndexParams(trees, branching, iterations, (::flann_centers_init_t)centers_init, cb_index));
 }
 
-::flann::Index* AutotunedIndexParams::createIndex(const Mat& dataset) const
+::cvflann::Index* AutotunedIndexParams::createIndex(const Mat& dataset) const
 {
 	CV_Assert(dataset.type() == CV_32F);
 	CV_Assert(dataset.isContinuous());
 
-	// TODO: fix ::flann::Matrix class so it can be constructed with a const float*
-	::flann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
+	// TODO: fix ::cvflann::Matrix class so it can be constructed with a const float*
+	::cvflann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
 
-	return new ::flann::Index(mat, ::flann::AutotunedIndexParams(target_precision, build_weight, memory_weight, sample_fraction));
+	return new ::cvflann::Index(mat, ::cvflann::AutotunedIndexParams(target_precision, build_weight, memory_weight, sample_fraction));
 }
 
-::flann::Index* SavedIndexParams::createIndex(const Mat& dataset) const
+::cvflann::Index* SavedIndexParams::createIndex(const Mat& dataset) const
 {
 	CV_Assert(dataset.type() == CV_32F);
 	CV_Assert(dataset.isContinuous());
 
-	// TODO: fix ::flann::Matrix class so it can be constructed with a const float*
-	::flann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
+	// TODO: fix ::cvflann::Matrix class so it can be constructed with a const float*
+	::cvflann::Matrix<float> mat(dataset.rows, dataset.cols, (float*)dataset.ptr<float>(0));
 
-	return new ::flann::Index(mat, ::flann::SavedIndexParams(filename));
+	return new ::cvflann::Index(mat, ::cvflann::SavedIndexParams(filename));
 }
 
 
@@ -121,11 +121,11 @@
 void Index::knnSearch(const vector<float>& query, vector<int>& indices, vector<float>& dists, int knn, const SearchParams& searchParams)
 {
 
-	::flann::Matrix<float> m_query(1, query.size(), (float*)&query[0]);
-	::flann::Matrix<int> m_indices(1, indices.size(), &indices[0]);
-	::flann::Matrix<float> m_dists(1, dists.size(), &dists[0]);
+	::cvflann::Matrix<float> m_query(1, query.size(), (float*)&query[0]);
+	::cvflann::Matrix<int> m_indices(1, indices.size(), &indices[0]);
+	::cvflann::Matrix<float> m_dists(1, dists.size(), &dists[0]);
 
-	nnIndex->knnSearch(m_query,m_indices,m_dists,knn,::flann::SearchParams(searchParams.checks));
+	nnIndex->knnSearch(m_query,m_indices,m_dists,knn,::cvflann::SearchParams(searchParams.checks));
 }
 
 
@@ -134,26 +134,26 @@
 
 	CV_Assert(queries.type() == CV_32F);
 	CV_Assert(queries.isContinuous());
-	::flann::Matrix<float> m_queries(queries.rows, queries.cols, (float*)queries.ptr<float>(0));
+	::cvflann::Matrix<float> m_queries(queries.rows, queries.cols, (float*)queries.ptr<float>(0));
 
 	CV_Assert(indices.type() == CV_32S);
 	CV_Assert(indices.isContinuous());
-	::flann::Matrix<int> m_indices(indices.rows, indices.cols, (int*)indices.ptr<int>(0));
+	::cvflann::Matrix<int> m_indices(indices.rows, indices.cols, (int*)indices.ptr<int>(0));
 
 	CV_Assert(dists.type() == CV_32F);
 	CV_Assert(dists.isContinuous());
-	::flann::Matrix<float> m_dists(dists.rows, dists.cols, (float*)dists.ptr<float>(0));
+	::cvflann::Matrix<float> m_dists(dists.rows, dists.cols, (float*)dists.ptr<float>(0));
 
-	nnIndex->knnSearch(m_queries,m_indices,m_dists,knn,::flann::SearchParams(searchParams.checks));
+	nnIndex->knnSearch(m_queries,m_indices,m_dists,knn,::cvflann::SearchParams(searchParams.checks));
 }
 
 int Index::radiusSearch(const vector<float>& query, vector<int>& indices, vector<float>& dists, float radius, const SearchParams& searchParams)
 {
-	::flann::Matrix<float> m_query(1, query.size(), (float*)&query[0]);
-	::flann::Matrix<int> m_indices(1, indices.size(), &indices[0]);
-	::flann::Matrix<float> m_dists(1, dists.size(), &dists[0]);
+	::cvflann::Matrix<float> m_query(1, query.size(), (float*)&query[0]);
+	::cvflann::Matrix<int> m_indices(1, indices.size(), &indices[0]);
+	::cvflann::Matrix<float> m_dists(1, dists.size(), &dists[0]);
 
-	return nnIndex->radiusSearch(m_query,m_indices,m_dists,radius,::flann::SearchParams(searchParams.checks));
+	return nnIndex->radiusSearch(m_query,m_indices,m_dists,radius,::cvflann::SearchParams(searchParams.checks));
 }
 
 
@@ -161,17 +161,17 @@
 {
 	CV_Assert(query.type() == CV_32F);
 	CV_Assert(query.isContinuous());
-	::flann::Matrix<float> m_query(query.rows, query.cols, (float*)query.ptr<float>(0));
+	::cvflann::Matrix<float> m_query(query.rows, query.cols, (float*)query.ptr<float>(0));
 
 	CV_Assert(indices.type() == CV_32S);
 	CV_Assert(indices.isContinuous());
-	::flann::Matrix<int> m_indices(indices.rows, indices.cols, (int*)indices.ptr<int>(0));
+	::cvflann::Matrix<int> m_indices(indices.rows, indices.cols, (int*)indices.ptr<int>(0));
 
 	CV_Assert(dists.type() == CV_32F);
 	CV_Assert(dists.isContinuous());
-	::flann::Matrix<float> m_dists(dists.rows, dists.cols, (float*)dists.ptr<float>(0));
+	::cvflann::Matrix<float> m_dists(dists.rows, dists.cols, (float*)dists.ptr<float>(0));
 
-	return nnIndex->radiusSearch(m_query,m_indices,m_dists,radius,::flann::SearchParams(searchParams.checks));
+	return nnIndex->radiusSearch(m_query,m_indices,m_dists,radius,::cvflann::SearchParams(searchParams.checks));
 }
 
 
@@ -195,13 +195,13 @@
 {
 	CV_Assert(features.type() == CV_32F);
 	CV_Assert(features.isContinuous());
-	::flann::Matrix<float> m_features(features.rows, features.cols, (float*)features.ptr<float>(0));
+	::cvflann::Matrix<float> m_features(features.rows, features.cols, (float*)features.ptr<float>(0));
 
 	CV_Assert(features.type() == CV_32F);
 	CV_Assert(features.isContinuous());
-	::flann::Matrix<float> m_centers(centers.rows, centers.cols, (float*)centers.ptr<float>(0));
+	::cvflann::Matrix<float> m_centers(centers.rows, centers.cols, (float*)centers.ptr<float>(0));
 
-	return ::flann::hierarchicalClustering(m_features, m_centers, ::flann::KMeansIndexParams(params.branching, params.iterations,
+	return ::cvflann::hierarchicalClustering(m_features, m_centers, ::cvflann::KMeansIndexParams(params.branching, params.iterations,
 			(::flann_centers_init_t)params.centers_init, params.cb_index));
 }
 
Index: 3rdparty/include/flann/flann.hpp
===================================================================
--- 3rdparty/include/flann/flann.hpp	(revision 3093)
+++ 3rdparty/include/flann/flann.hpp	(working copy)
@@ -40,7 +40,7 @@
 
 #include "flann.h"
 
-namespace flann
+namespace cvflann
 {
 
 class NNIndex;
Index: 3rdparty/include/flann/random.h
===================================================================
--- 3rdparty/include/flann/random.h	(revision 3093)
+++ 3rdparty/include/flann/random.h	(working copy)
@@ -37,7 +37,7 @@
 
 using namespace std;
 
-namespace flann
+namespace cvflann
 {
 
 /**
Index: 3rdparty/include/flann/matrix.h
===================================================================
--- 3rdparty/include/flann/matrix.h	(revision 3093)
+++ 3rdparty/include/flann/matrix.h	(working copy)
@@ -35,7 +35,7 @@
 #include "random.h"
 
 
-namespace flann
+namespace cvflann
 {
 /**
 * Class implementing a generic rectangular dataset.
Index: 3rdparty/include/flann/common.h
===================================================================
--- 3rdparty/include/flann/common.h	(revision 3093)
+++ 3rdparty/include/flann/common.h	(working copy)
@@ -36,7 +36,7 @@
 
 #include <stdexcept>
 
-namespace flann
+namespace cvflann
 {
 class FLANNException : public std::runtime_error {
  public:
Index: 3rdparty/flann/flann.cpp
===================================================================
--- 3rdparty/flann/flann.cpp	(revision 3093)
+++ 3rdparty/flann/flann.cpp	(working copy)
@@ -58,7 +58,7 @@
 #endif
 
 
-namespace flann
+namespace cvflann
 {
 
 typedef ObjectFactory<IndexParams, flann_algorithm_t> ParamsFactory;
@@ -224,7 +224,7 @@
 
 
 
-using namespace flann;
+using namespace cvflann;
 
 typedef NNIndex* NNIndexPtr;
 typedef Matrix<float>* MatrixPtr;
Index: 3rdparty/flann/flann.hpp
===================================================================
--- 3rdparty/flann/flann.hpp	(revision 3093)
+++ 3rdparty/flann/flann.hpp	(working copy)
@@ -40,7 +40,7 @@
 
 #include "flann.h"
 
-namespace flann
+namespace cvflann
 {
 
 class NNIndex;
Index: 3rdparty/flann/algorithms/composite_index.h
===================================================================
--- 3rdparty/flann/algorithms/composite_index.h	(revision 3093)
+++ 3rdparty/flann/algorithms/composite_index.h	(working copy)
@@ -34,7 +34,7 @@
 #include "constants.h"
 #include "nn_index.h"
 
-namespace flann
+namespace cvflann
 {
 
 class CompositeIndex : public NNIndex
Index: 3rdparty/flann/algorithms/dist.cpp
===================================================================
--- 3rdparty/flann/algorithms/dist.cpp	(revision 3093)
+++ 3rdparty/flann/algorithms/dist.cpp	(working copy)
@@ -30,7 +30,7 @@
 
 #include "dist.h"
 
-namespace flann
+namespace cvflann
 {
 
 /** Global variable indicating the distance metric
Index: 3rdparty/flann/algorithms/autotuned_index.h
===================================================================
--- 3rdparty/flann/algorithms/autotuned_index.h	(revision 3093)
+++ 3rdparty/flann/algorithms/autotuned_index.h	(working copy)
@@ -36,7 +36,7 @@
 #include "ground_truth.h"
 #include "index_testing.h"
 
-namespace flann
+namespace cvflann
 {
 
 class AutotunedIndex : public NNIndex
Index: 3rdparty/flann/algorithms/linear_index.h
===================================================================
--- 3rdparty/flann/algorithms/linear_index.h	(revision 3093)
+++ 3rdparty/flann/algorithms/linear_index.h	(working copy)
@@ -34,7 +34,7 @@
 #include "constants.h"
 #include "nn_index.h"
 
-namespace flann
+namespace cvflann
 {
 
 class LinearIndex : public NNIndex {
Index: 3rdparty/flann/algorithms/nn_index.h
===================================================================
--- 3rdparty/flann/algorithms/nn_index.h	(revision 3093)
+++ 3rdparty/flann/algorithms/nn_index.h	(working copy)
@@ -41,7 +41,7 @@
 
 using namespace std;
 
-namespace flann
+namespace cvflann
 {
 
 class ResultSet;
Index: 3rdparty/flann/algorithms/dist.h
===================================================================
--- 3rdparty/flann/algorithms/dist.h	(revision 3093)
+++ 3rdparty/flann/algorithms/dist.h	(working copy)
@@ -36,7 +36,7 @@
 
 #include "constants.h"
 
-namespace flann
+namespace cvflann
 {
 
 /**
Index: 3rdparty/flann/algorithms/kdtree_index.h
===================================================================
--- 3rdparty/flann/algorithms/kdtree_index.h	(revision 3093)
+++ 3rdparty/flann/algorithms/kdtree_index.h	(working copy)
@@ -48,7 +48,7 @@
 using namespace std;
 
 
-namespace flann
+namespace cvflann
 {
 
 
Index: 3rdparty/flann/algorithms/kmeans_index.h
===================================================================
--- 3rdparty/flann/algorithms/kmeans_index.h	(revision 3093)
+++ 3rdparty/flann/algorithms/kmeans_index.h	(working copy)
@@ -50,7 +50,7 @@
 using namespace std;
 
 
-namespace flann
+namespace cvflann
 {
 
 /**
Index: 3rdparty/flann/nn/index_testing.cpp
===================================================================
--- 3rdparty/flann/nn/index_testing.cpp	(revision 3093)
+++ 3rdparty/flann/nn/index_testing.cpp	(working copy)
@@ -40,7 +40,7 @@
 #include <string.h>
 #include <stdlib.h>
 
-namespace flann
+namespace cvflann
 {
 
 const float SEARCH_EPS = 0.001f;
Index: 3rdparty/flann/nn/simplex_downhill.h
===================================================================
--- 3rdparty/flann/nn/simplex_downhill.h	(revision 3093)
+++ 3rdparty/flann/nn/simplex_downhill.h	(working copy)
@@ -31,7 +31,7 @@
 #ifndef SIMPLEX_DOWNHILL_H
 #define SIMPLEX_DOWNHILL_H
 
-namespace flann
+namespace cvflann
 {
 
 /**
Index: 3rdparty/flann/nn/ground_truth.h
===================================================================
--- 3rdparty/flann/nn/ground_truth.h	(revision 3093)
+++ 3rdparty/flann/nn/ground_truth.h	(working copy)
@@ -34,7 +34,7 @@
 #include "matrix.h"
 #include "dist.h"
 
-namespace flann
+namespace cvflann
 {
 
 template <typename T>
Index: 3rdparty/flann/nn/index_testing.h
===================================================================
--- 3rdparty/flann/nn/index_testing.h	(revision 3093)
+++ 3rdparty/flann/nn/index_testing.h	(working copy)
@@ -38,7 +38,7 @@
 
 using namespace std;
 
-namespace flann
+namespace cvflann
 {
 
 void search_for_neighbors(NNIndex& index, const Matrix<float>& testset, Matrix<int>& result, Matrix<float>& dists, const SearchParams &searchParams, int skip = 0);
Index: 3rdparty/flann/util/result_set.h
===================================================================
--- 3rdparty/flann/util/result_set.h	(revision 3093)
+++ 3rdparty/flann/util/result_set.h	(working copy)
@@ -40,7 +40,7 @@
 using namespace std;
 
 
-namespace flann
+namespace cvflann
 {
 
 /* This record represents a branch point when finding neighbors in
Index: 3rdparty/flann/util/logger.cpp
===================================================================
--- 3rdparty/flann/util/logger.cpp	(revision 3093)
+++ 3rdparty/flann/util/logger.cpp	(working copy)
@@ -36,7 +36,7 @@
 
 using namespace std;
 
-namespace flann
+namespace cvflann
 {
 
 Logger logger;
Index: 3rdparty/flann/util/random.cpp
===================================================================
--- 3rdparty/flann/util/random.cpp	(revision 3093)
+++ 3rdparty/flann/util/random.cpp	(working copy)
@@ -31,7 +31,7 @@
 #include "random.h"
 
 
-namespace flann
+namespace cvflann
 {
 
 void seed_random(unsigned int seed)
Index: 3rdparty/flann/util/heap.h
===================================================================
--- 3rdparty/flann/util/heap.h	(revision 3093)
+++ 3rdparty/flann/util/heap.h	(working copy)
@@ -35,7 +35,7 @@
 #include <algorithm>
 using namespace std;
 
-namespace flann
+namespace cvflann
 {
 
 /**
Index: 3rdparty/flann/util/object_factory.h
===================================================================
--- 3rdparty/flann/util/object_factory.h	(revision 3093)
+++ 3rdparty/flann/util/object_factory.h	(working copy)
@@ -33,7 +33,7 @@
 
 #include <map>
 
-namespace flann
+namespace cvflann
 {
 
 template<typename BaseClass, typename DerivedClass>
Index: 3rdparty/flann/util/logger.h
===================================================================
--- 3rdparty/flann/util/logger.h	(revision 3093)
+++ 3rdparty/flann/util/logger.h	(working copy)
@@ -39,7 +39,7 @@
 
 using namespace std;
 
-namespace flann
+namespace cvflann
 {
 
 class Logger
Index: 3rdparty/flann/util/allocator.h
===================================================================
--- 3rdparty/flann/util/allocator.h	(revision 3093)
+++ 3rdparty/flann/util/allocator.h	(working copy)
@@ -35,7 +35,7 @@
 #include <stdio.h>
 
 
-namespace flann
+namespace cvflann
 {
 
 /**
Index: 3rdparty/flann/util/random.h
===================================================================
--- 3rdparty/flann/util/random.h	(revision 3093)
+++ 3rdparty/flann/util/random.h	(working copy)
@@ -37,7 +37,7 @@
 
 using namespace std;
 
-namespace flann
+namespace cvflann
 {
 
 /**
Index: 3rdparty/flann/util/timer.h
===================================================================
--- 3rdparty/flann/util/timer.h	(revision 3093)
+++ 3rdparty/flann/util/timer.h	(working copy)
@@ -34,7 +34,7 @@
 #include <time.h>
 
 
-namespace flann
+namespace cvflann
 {
 
 /**
Index: 3rdparty/flann/util/saving.cpp
===================================================================
--- 3rdparty/flann/util/saving.cpp	(revision 3093)
+++ 3rdparty/flann/util/saving.cpp	(working copy)
@@ -33,7 +33,7 @@
 #include "nn_index.h"
 #include <cstdio>
 
-namespace flann
+namespace cvflann
 {
 
 const char FLANN_SIGNATURE[] = "FLANN_INDEX";
Index: 3rdparty/flann/util/matrix.h
===================================================================
--- 3rdparty/flann/util/matrix.h	(revision 3093)
+++ 3rdparty/flann/util/matrix.h	(working copy)
@@ -35,7 +35,7 @@
 #include <random.h>
 
 
-namespace flann
+namespace cvflann
 {
 /**
 * Class implementing a generic rectangular dataset.
Index: 3rdparty/flann/util/saving.h
===================================================================
--- 3rdparty/flann/util/saving.h	(revision 3093)
+++ 3rdparty/flann/util/saving.h	(working copy)
@@ -35,7 +35,7 @@
 #include "nn_index.h"
 
 
-namespace flann
+namespace cvflann
 {
 
 /**
Index: 3rdparty/flann/util/common.h
===================================================================
--- 3rdparty/flann/util/common.h	(revision 3093)
+++ 3rdparty/flann/util/common.h	(working copy)
@@ -36,7 +36,7 @@
 
 #include <stdexcept>
 
-namespace flann
+namespace cvflann
 {
 class FLANNException : public std::runtime_error {
  public:
